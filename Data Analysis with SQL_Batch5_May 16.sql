# Data Analysis with SQL 

# all fields, all records 

SELECT * FROM customers;
SELECT * FROM orders;
SELECT * FROM product_items;

# selected fields, all records 

SELECT first_name, last_name, age, city
FROM customers;

SELECT 
	first_name AS customer_name, 
    last_name, 
    age
FROM customers;

SELECT 
	first_name AS customer_name, 
    last_name, 
    age, 
    age + 10 AS adding_new_age
FROM customers;

# selected fields, limited rows 

SELECT 
	first_name AS customer_name, 
    last_name, 
    age, 
    city
FROM customers
LIMIT 5;

SELECT * FROM product_items
LIMIT 3;


# Where (Filtering) 

SELECT * FROM customers;

SELECT 
	first_name, 
    last_name, 
    address,
    city
FROM customers
WHERE city = "Springfield";

SELECT *
FROM customers
WHERE gender = "Male";

SELECT * FROM orders;

SELECT *
FROM orders
WHERE quantity = 7;

SELECT *
FROM orders
WHERE quantity >= 10;

SELECT *
FROM orders
WHERE quantity < 5;

SELECT *
FROM orders
WHERE total_amount > 500;

SELECT 
	customer_id,
    first_name, 
    last_name, 
    address,
    age,
    city
FROM customers
WHERE city = "Springfield";


# OR  (either or : either A or B)

SELECT *
FROM customers
WHERE city = "Springfield" OR city = "Chicago";

SELECT *
FROM customers
WHERE city = "Springfield" OR age > 40;  # either or

# AND (must be meet with both condition)

SELECT *
FROM customers
WHERE city = "Springfield" AND age > 30;

# Customer list who age between 30 and 40 

SELECT *
FROM customers
WHERE age BETWEEN 30 AND 40;

SELECT *
FROM customers
WHERE age NOT BETWEEN 30 AND 40;

SELECT *
FROM customers
WHERE date_of_birth BETWEEN "1985-01-01" AND "1990-12-31";

SELECT *
FROM customers
WHERE date_of_birth BETWEEN "1965-01-01" AND "2012-12-31";


# combination of AND, OR

# find orders where the qty is > 10, and total amt > 300
# or placed after "2024-05-24"

SELECT *
FROM orders
WHERE (quantity > 10 AND total_amount > 300) 
	OR order_date > "2024-05-24";

# Find customers who either live in "Springfield" and are younger than 30
# or live in Chicago and are older than 40

SELECT *
FROM customers
WHERE (city = "Springfiled" AND age < 30)
	OR (city = "Chicago" AND age > 40);


SELECT * FROM customers;

# IN, NOT IN

# find orders when the product_id is either 1, 3 or 5

SELECT *
FROM orders
WHERE product_id = 1
	OR product_id = 3
    OR product_id = 5;

SELECT *
FROM orders
WHERE product_id IN (1, 3, 5);

SELECT *
FROM orders
WHERE product_id NOT IN (1, 3, 5);

SELECT customer_id, first_name, last_name, age, gender, city
FROM customers 
WHERE city IN ("Springfield", "Chicago", "Joliet");

SELECT customer_id, first_name, last_name, age, gender, city
FROM customers 
WHERE city NOT IN ("Springfield", "Chicago", "Joliet");


# IS NULL, IS NOT NULL

SELECT *
FROM customers
WHERE email IS NULL;

SELECT *
FROM customers
WHERE email IS NOT NULL;


# LIKE, NOT LIKE 

SELECT *
FROM customers
WHERE first_name = "Mary";


SELECT *
FROM customers
WHERE first_name LIKE "Ma%";  # % : sequence of characters


SELECT *
FROM customers
WHERE first_name LIKE "Ma__"; # _ : one character

SELECT *
FROM customers
WHERE first_name LIKE "Ma_%";

SELECT *
FROM customers
WHERE first_name LIKE "%ry";

SELECT *
FROM customers
WHERE first_name LIKE "__ry";

SELECT *
FROM customers
WHERE first_name LIKE "%ar%";

SELECT *
FROM customers
WHERE date_of_birth LIKE "1985%";

# retrieve all products that its name contains (starts with) Floral 

SELECT *
FROM product_items
WHERE product_name LIKE "%Floral%";

# find orders where total amt contains the number 99 

SELECT *
FROM orders
WHERE total_amount LIKE "%99";

# retrieve all products that do not contain "Leather"

SELECT *
FROM product_items
WHERE product_name NOT LIKE "%Leather%";

SELECT *
FROM product_items
WHERE product_name NOT LIKE "%Shirt%";


# AGGREGATE FUNCTIONS 

# total order amount

SELECT SUM(total_amount) AS total_order_amount
FROM orders;

SELECT AVG(total_amount) AS avg_order_amt
FROM orders;

SELECT COUNT(*)
FROM customers;


# GROUP BY 

SELECT gender, AVG(age), MAX(age), MIN(age), COUNT(age)
FROM customers
GROUP BY gender;

# customer count by city 

SELECT city, COUNT(city)
FROM customers
GROUP BY city;

SELECT category, SUM(stock)
FROM product_items
GROUP BY category;

# find the total qty sold for each product 

SELECT 
	product_id, 
    SUM(quantity) AS total_qty_sold
FROM orders
GROUP BY product_id
ORDER BY total_qty_sold DESC
LIMIT 3;  # DESC, ASC

SELECT 
	product_id, 
    SUM(quantity) AS total_qty_sold
FROM orders
GROUP BY product_id
ORDER BY total_qty_sold ASC;

# calculate the total number of order and total revenue generated by each customer 

SELECT 
	customer_id,
    COUNT(order_id) AS total_orders, 
    SUM(total_amount) AS total_revenue
FROM orders 
GROUP BY customer_id
ORDER BY total_revenue DESC;


# ORDER BY 

SELECT * 
FROM customers 
ORDER BY gender ASC, age DESC;

SELECT * 
FROM customers 
ORDER BY age DESC, gender;

# HAVING 

SELECT 
	customer_id,
    SUM(total_amount) AS total_revenue
FROM orders 
-- grouping the customers
GROUP BY customer_id
-- filter out with total amount < 500
HAVING SUM(total_amount) <= 500
-- sorting by total_revenue
ORDER BY total_revenue;

# WHERE - general condition 

# HAVING - agg, group by

# For orders in 2024, analyse the total quantity sold by product-wise, 
# but only for the products with more than 5 orders. Sort by Qty Sold in DESC order. 

SELECT 
	product_id, 
    SUM(quantity) AS total_qty_sold,
    COUNT(order_id) AS order_count
FROM orders 
-- filtering for Yr 2024
WHERE YEAR(order_date) = 2024
-- total quantity sold by product-wise
GROUP BY product_id
-- products with more than 5 orders
HAVING order_count > 5
-- sorting the column with DESC
ORDER BY total_qty_sold DESC;

# analyze total orders per customer in 2025, only include those 
# who spent over $500 in total, and sort them by total spent in descending order.

SELECT 
	customer_id, 
    COUNT(order_id) AS total_order, 
    SUM(total_amount) AS total_spent
FROM orders 
WHERE YEAR(order_date) = 2025
GROUP BY customer_id
HAVING total_spent > 500
ORDER BY total_spent DESC;

SELECT 
	customers.customer_id, 
    first_name, 
    last_name,
    age,
    city,
    COUNT(order_id) AS total_order, 
    SUM(total_amount) AS total_spent
FROM orders 
INNER JOIN customers 
	ON orders.customer_id = customers.customer_id
WHERE YEAR(order_date) = 2025
GROUP BY customer_id
HAVING total_spent > 500
ORDER BY total_spent DESC;

SELECT 
	c.customer_id, 
    c.first_name, 
    c.last_name,
    c.age,
    c.city,
    COUNT(o.order_id) AS total_order, 
    SUM(o.total_amount) AS total_spent
FROM orders o 
INNER JOIN customers c 
	ON o.customer_id = c.customer_id
WHERE YEAR(o.order_date) = 2025
GROUP BY c.customer_id
HAVING total_spent > 500
ORDER BY total_spent DESC;

-- JOIN 

CREATE DATABASE IF NOT EXISTS employee1;

Use employee1;

CREATE TABLE employee 
(
	employee_id int, 
    emp_name varchar(10), 
    department_id int
);

CREATE TABLE department
(
	department_id int,
    department_name varchar(10)
);

INSERT INTO employee (employee_id, emp_name, department_id)
VALUES
(1, 'Alice', 10),
(2, 'Bob', 20),
(3, 'Charlie', 30),
(4, 'David', 40);

INSERT INTO employee (employee_id, emp_name, department_id)
VALUES
(5, 'Mary', 50);

INSERT INTO department (department_id, department_name) 
VALUES 
(10, 'HR'), 
(20, 'IT'), 
(30, 'Finance'),
(40, 'Marketing');

SELECT * FROM employee;
SELECT * FROM department;

# inner join 

SELECT * 
FROM employee e # A / table 1
INNER JOIN department d # B / table 2
	ON e.department_id = d.department_id;

SELECT * 
FROM employee e # A / table 1
LEFT JOIN department d # B / table 2
	ON e.department_id = d.department_id;

SELECT * 
FROM department d # A / table 1
LEFT JOIN employee e # B / table 2
	ON e.department_id = d.department_id;

SELECT * 
FROM employee e # A / table 1
RIGHT JOIN department d # B / table 2
	ON e.department_id = d.department_id;

SELECT * 
FROM employee e # A / table 1
CROSS JOIN department d;


-- ECOMMERCE 

# get customer detail, product details, and order details 

SELECT 
	c.first_name, 
    c.last_name, 
    p.product_name,
    o.quantity,
    o.total_amount
FROM orders o
INNER JOIN customers c 
	ON o.customer_id = c.customer_id
INNER JOIN product_items p 
	ON o.product_id = p.product_id;

# recent customer orders 

SELECT * 
FROM orders 
ORDER BY order_date DESC
LIMIT 3;


SELECT 
	o.order_id,
    o.order_date, 
    c.first_name,
    c.last_name,
    p.product_name,
    o.quantity,
    o.total_amount
FROM orders o
INNER JOIN customers c 
	ON o.customer_id = c.customer_id
INNER JOIN product_items p 
	ON o.product_id = p.product_id
ORDER BY order_date DESC
LIMIT 3;

# customer spending patterns

SELECT 
	c.customer_id, 
    CONCAT(c.first_name, " ", c.last_name) AS customer_full_name, 
    COUNT(o.order_id) AS number_of_orders, 
    SUM(o.total_amount) AS total_spent, 
    AVG(o.total_amount) AS avg_order_amt
-- table location
FROM orders o 
JOIN customers c 
	ON o.customer_id = c.customer_id
-- grouping by customer 
GROUP BY c.customer_id
ORDER BY total_spent DESC;


# JOINs (April 18, 2025) 

SELECT * FROM customers; 
SELECT * FROM orders;

SELECT 
	c.customer_id,
    c.first_name,
    c.last_name,
    c.city,
    o.total_amount
FROM customers c # table 1 / A
JOIN orders o # table 2 / B
	ON c.customer_id = o.customer_id;


SELECT * 
FROM customers c  # table 1 / A
LEFT JOIN orders o # table 2 / B 
	ON c.customer_id = o.customer_id;


SELECT * 
FROM customers c  # table 1 / A
RIGHT JOIN orders o # table 2 / B 
	ON c.customer_id = o.customer_id;

SELECT * 
FROM orders o # table 1 / A
LEFT JOIN customers c  # table 2 / B 
	ON c.customer_id = o.customer_id;

# Ecommerce data

SELECT 
	c.customer_id, 
    c.city,
    o.order_date,
    o.total_amount
FROM customers c
JOIN orders o 
	ON c.customer_id = o.customer_id
WHERE YEAR(o.order_date) = 2025;

SELECT 
	p.product_id,
    p.product_name,
    SUM(o.quantity) AS total_qty
FROM product_items p
LEFT JOIN orders o 
	ON p.product_id = o.product_id
GROUP BY p.product_id
HAVING SUM(o.quantity) > 50
ORDER BY total_qty DESC;

# sample dataset to practice JOINs 

------ JOIN 

CREATE SCHEMA sample_data;

-- Create Marketing_Campaigns Table
CREATE TABLE Marketing_Campaigns (
    CampaignID INT PRIMARY KEY,
    CampaignName VARCHAR(50),
    StartDate DATE,
    EndDate DATE,
    Budget DECIMAL(10, 2)
);

-- Insert data into Marketing_Campaigns
INSERT INTO Marketing_Campaigns (CampaignID, CampaignName, StartDate, EndDate, Budget)
VALUES
(1, 'Summer Sale', '2025-06-01', '2025-06-30', 10000),
(2, 'Winter Clearance', '2025-12-01', '2025-12-31', 15000),
(3, 'New Year Promo', '2026-01-01', '2026-01-15', 20000);

-- Create Sales_Records Table
CREATE TABLE Sales_Records (
    SaleID INT PRIMARY KEY,
    CampaignID INT,
    SaleDate DATE,
    Amount DECIMAL(10, 2),
    FOREIGN KEY (CampaignID) REFERENCES Marketing_Campaigns(CampaignID) ON DELETE CASCADE
);

-- Insert data into Sales_Records
INSERT INTO Sales_Records (SaleID, CampaignID, SaleDate, Amount)
VALUES
(101, 1, '2025-06-05', 2500),
(102, 1, '2025-06-10', 3000),
(103, 2, '2025-12-05', 7000),
(104, 3, '2026-01-10', 12000),
(105, NULL, '2025-11-15', 800);


# SELF JOIN

CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY AUTO_INCREMENT, 
    FirstName VARCHAR(50) NOT NULL,
    LastName VARCHAR(50) NOT NULL,
    Department VARCHAR(50) NOT NULL,
    Salary DECIMAL(10, 2) NOT NULL,
    ManagerID INT,
    HireDate DATE
);

INSERT INTO Employees (EmployeeID, FirstName, LastName, Department, Salary, ManagerID, HireDate)
VALUES
(1, 'Alice', 'Smith', 'Digital Ads', 5000, NULL, '2022-01-10'),
(2, 'Bob', 'Jones', 'Digital Ads', 4500, 1, '2023-03-15'),
(3, 'Charlie', 'Brown', 'Content', 4000, NULL, '2021-07-20'),
(4, 'Diana', 'Prince', 'Digital Ads', 4700, 1, '2023-05-10'),
(5, 'Eve', 'Johnson', 'Content', 4200, 3, '2023-09-01');

SELECT * FROM employees;

# compare employees in the same department by using self join

SELECT 
	A.FirstName AS Employee1, 
    B.FirstName AS Employee2, 
    A.Department,
    A.Salary AS Salary1, 
    B.Salary AS Salary2
FROM employees A
JOIN employees B 
	ON A.department = B.department
		AND A.EmployeeID <> B.EmployeeID;

SELECT 
*
FROM employees A
JOIN employees B 
	ON A.EmployeeID + 1 = B.EmployeeID;



# UNION 
# use UNION to combine the results of both queries


SELECT first_name, last_name, email
FROM customers 
WHERE gender = "Female";

SELECT first_name, last_name, email
FROM customers 
WHERE gender = "Male";

SELECT first_name, last_name, email
FROM customers 
WHERE gender = "Female"
UNION  # UNION ALL - include duplicate   UNION DISTINCT 
SELECT first_name, last_name, email
FROM customers 
WHERE gender = "Male";

# customer classification into different categories based on their age

SELECT first_name, last_name, age, city, "Older Customer" AS Label
FROM customers
WHERE age > 45
UNION
SELECT first_name, last_name, age, city, "Old Lady" AS Label
FROM customers
WHERE age > 40 AND gender = "Female"
UNION
SELECT first_name, last_name, age, city, "Young Customer" AS Label
FROM customers
WHERE age < 30;


# CASE Statement 

# Simple CASE 

SELECT 
*
FROM product_items;

SELECT product_name, price,
	CASE price 
		WHEN 19.99 THEN "Discounted"
        WHEN 29.99 THEN "Mid-Range"
        WHEN 49.99 THEN "Premium"
        ELSE "Other"
	END AS price_category
FROM product_items;

# search CASE 

SELECT 
	first_name, 
    last_name, 
    age,
	CASE 
		WHEN age <= 30 THEN "Young"
        WHEN age BETWEEN 31 AND 45 THEN "Adult" 
		WHEN age >=46 THEN "Senior"
	END AS age_category, 
    city
FROM customers;

# situation 1: pricing strategy, if setting new pricing 
# if price < 20, 5% increase 
# if price between 20 and 30, 10% increase 
# if price > 30, apply 15% increase

# situation 2: if stock < 50, apply 10% bonus
# if stock > 50, zero bonus

SELECT 
	product_name, 
    price,
    CASE 
		WHEN price < 20 THEN price * 1.05 -- apply 5% price increase
        WHEN price BETWEEN 20 AND 30 THEN price * 1.10 -- 10% price increase
		ELSE price * 1.15 -- apply 15%
	END AS new_price,
    CASE
		WHEN stock < 70 THEN price * 0.10 -- apply 10% bonus adjustment for low stock items
        ELSE 0
	END AS stock_bonus
FROM product_items;

DROP TABLE employees;

# CASE... WHERE 

# amount < 200, then low order amount   amount = 200 / women clothing
# amount >= 500, then high order amount
# show the result only for either <200 or >= 500 order transactions

SELECT 
	o.order_id, 
    c.customer_id,
    c.age,
    c.city,
    o.total_amount, 
    CASE 
		WHEN total_amount < 200 THEN "Low Order Amount"
        WHEN total_amount >= 500 THEN "High Order Amount"
	END AS order_classification
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id
WHERE o.total_amount < 200 OR o.total_amount >=500;


# ordering products by stock status 
# stock status : in stock > 80, low stock 55~80 , out of stock 
# order the result based on these categories 

SELECT 
	product_id, 
    product_name, 
    stock, 
    category, 
    CASE
		WHEN stock > 80 THEN "In Stock"
        WHEN stock BETWEEN 55 AND 80 THEN "Low Stock" 
		ELSE "Out of Stock"
    END AS stock_status
FROM product_items
ORDER BY 
	CASE 
		WHEN stock > 80 THEN 1
        WHEN stock BETWEEN 55 AND 80 THEN 2
        ELSE 3
	END;

# price < 20 and stock > 75, then categorize as "Low price, High stock" 
# price between 20 and 40 and stock < 75, "Medium price, Low stock" 
# price > 40 and stock < 50, then "High price, Limited stock"

SELECT 
	product_id, 
    product_name, 
    price, 
    stock,
    CASE 
		WHEN price < 20 AND stock > 75 THEN "Low price, High stock"
        WHEN (price BETWEEN 20 AND 40) AND stock < 75 THEN "Medium price, Low stock"
        WHEN price > 40 AND stock < 50 THEN "High price, Limited stock"
        ELSE "Other"
	END AS price_stock_category
FROM product_items;

# update 

UPDATE product_items 
SET stock = 
	CASE 
		WHEN category = "Women Clothing" THEN stock + 20
        WHEN category = "Men Clothing" THEN stock + 10
        ELSE stock
	END
WHERE stock < 100;


# Aggregate

SELECT 
	gender, 
    COUNT(*) AS customer_count, 
    CASE 
		WHEN gender = "Male" THEN "Men" 
        WHEN gender = "Female" THEN "Women"
	END AS gender_label
FROM customers
GROUP BY gender;


# Subquery 

# find the customers who placed orders worth more than $500

SELECT *
FROM orders
WHERE total_amount > 500;

SELECT 
	o.customer_id, 
    c.first_name,
    c.last_name,
    o.total_amount
FROM orders o
JOIN customers c
	ON o.customer_id = c.customer_id
WHERE total_amount > 500;

# customer list (customer data)
# total_amt > 500 (orders table) 

SELECT * 										# outer query
FROM customers 
WHERE customer_id IN (								# EXISTS for big data
						SELECT customer_id			# inner query / nested query
						FROM orders
						WHERE total_amount > 500);

# customers who living in Joliet, are ordering which items 

SELECT * 
FROM product_items
WHERE product_id IN (
						SELECT product_id 
                        FROM orders 
                        WHERE customer_id IN (
												SELECT customer_id		# inner most query
                                                FROM customers 
                                                WHERE city = "Joliet"));

# find customers who placed order with qty (xx) which higher than * avg order qty accross all orders 

SELECT 
	customer_id, 
    first_name, 
    last_name, 
    city, 
    email
FROM customers
WHERE customer_id IN (
						SELECT customer_id
						FROM orders 
						WHERE quantity > (
											SELECT AVG(quantity)
											FROM orders));

SELECT product_id, product_name, price, AVG(price)
FROM product_items 
GROUP BY product_id;

SELECT 
	product_id, 
    product_name, 
    price, 
    (SELECT ROUND(AVG(price),2)
    FROM product_items) AS overall_avg_price
FROM product_items 
GROUP BY product_id;

SELECT gender, AVG(age), MAX(age), MIN(age), COUNT(age)
FROM customers 
GROUP BY gender;

SELECT 
    AVG(max_age)
FROM
    (SELECT 
        gender, 
        AVG(age) AS avg_age, 
        MAX(age) AS max_age, 
        MIN(age) AS min_age, 
        COUNT(age)
    FROM
        customers
    GROUP BY gender) AS agg_data;


# calculate the total number of product sold for each product 

SELECT 
	product_name,
    category,
    price, 
    (SELECT SUM(quantity)
    FROM orders
    WHERE orders.product_id = product_items.product_id) AS total_qty_sold
FROM product_items;


# find the no. 1 top customer based on their total spending 

SELECT first_name, last_name, email, total_spent
FROM (
	SELECT 
		customer_id, 
		SUM(total_amount) AS total_spent
	FROM orders
	GROUP BY customer_id
	ORDER BY total_spent DESC
	LIMIT 1) AS top_customer
JOIN customers 
ON top_customer.customer_id = customers.customer_id;

SELECT 
	product_id,
    product_name, 
    category,
    price
FROM product_items 
WHERE product_id IN (
						SELECT product_id
						FROM orders
						GROUP BY product_id
						HAVING SUM(quantity) < (
												SELECT AVG(quantity)
												FROM orders));

# increase the price of products that have been ordered more than 50 qty by 10% 

UPDATE product_items
SET price = price * 1.10;
# WHERE product_id IN ;


# STRING 

SELECT first_name, LENGTH(first_name)
FROM customers;

SELECT first_name, UPPER(first_name), gender
FROM customers;

SELECT first_name, LOWER(first_name), gender
FROM customers;

SELECT TRIM("                apple           ");

SELECT 
	first_name,
    LEFT(first_name, 4),
    RIGHT(first_name, 4),
    SUBSTRING(first_name, 3, 3),
    date_of_birth, 
    SUBSTRING(date_of_birth, 6, 2) AS birth_month
FROM customers;

SELECT 
	first_name, 
    REPLACE(first_name, "a", "g")
FROM customers;

SELECT 
	first_name, 
    LOCATE("tr", first_name)
FROM customers;

SELECT 
	first_name, 
    last_name, 
    CONCAT(first_name, ' ', last_name) 
FROM customers;



# Advanced SQL 

# VIEW

# customer order summary 

CREATE VIEW customer_order_summary1 AS
SELECT 
	c.first_name, 
    c.last_name, 
    c.city,
    p.product_name, 
    o.total_amount,
    o.order_date
FROM orders o 
JOIN customers c 
	ON o.customer_id = c.customer_id
JOIN product_items p 
	ON o.product_id = p.product_id;

SELECT * FROM customer_order_summary1;
SELECT * FROM customers;

DROP VIEW IF EXISTS customer_order_summary1;


# WINDOW FUNCTIONS 

# we want to assign a row number to each customer's order
# partitioned by the customer (similar with group by, but keep duplicate)


SELECT 
	customer_id, 
    product_id,
    total_amount,
    order_date,
    ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date) AS order_rank
FROM orders; 


SELECT 
	c.gender, AVG(o.total_amount)
FROM customers c 
JOIN orders o 
	ON c.customer_id = o.customer_id
GROUP BY gender;

SELECT 
	c.first_name, 
    c.last_name, 
    c.gender,
    o.total_amount,
    AVG(o.total_amount) OVER(PARTITION BY gender)
FROM customers c 
JOIN orders o 
	ON c.customer_id = o.customer_id;


# ranking : rank, dense_rank, row number  rank()
# agg (sum, avg, count, max, min)   sum(col_name)
# lag, lead   lag(col_name)
# row number 

SELECT 
	customer_id, 
    product_id,
    total_amount,
    order_date,
    ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date) AS order_rank
FROM orders; 

# ranking 

# ranking orders by customers 

SELECT 
	order_id, 
    customer_id, 
    total_amount, 
    order_date, 
    RANK() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS rank_per_customer
FROM orders;

# finding top 2 most expensive orders per customer 

WITH ranked_orders AS (
	SELECT 
		customer_id,
        product_id, 
        total_amount,
        RANK() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS rank_num
	FROM orders)
SELECT * 
FROM ranked_orders
WHERE rank_num <= 2;

# using dense_rank() instead of rank()

WITH ranked_orders AS (
	SELECT 
		customer_id,
        product_id, 
        total_amount,
        DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS rank_num
	FROM orders)
SELECT * 
FROM ranked_orders
WHERE rank_num <= 2;


SELECT DISTINCT 
	c.first_name, 
    c.last_name, 
    c.gender, 
    o.total_amount, 
    ROW_NUMBER() OVER(PARTITION BY gender ORDER BY total_amount DESC) AS row_num, 
    RANK() OVER(PARTITION BY gender ORDER BY total_amount DESC) AS rank_num, 
    DENSE_RANK() OVER(PARTITION BY gender ORDER BY total_amount DESC) AS dense_rank_num
FROM customers c
JOIN orders o 
	ON c.customer_id = o.customer_id;


# agg (sum, avg, count, max, min) 

# running total for each customers

SELECT 
	order_id, 
    customer_id, 
    total_amount, 
    order_date, 
    SUM(total_amount) OVER(PARTITION BY customer_id ORDER BY order_date) AS running_total
FROM orders;


# total order amt per customer

SELECT 
	order_id, 
    customer_id, 
    total_amount, 
    order_date, 
    SUM(total_amount) OVER(PARTITION BY customer_id) AS total_spent_by_customer
FROM orders;


# average order amt by product category 

SELECT 
	o.order_id, 
    p.category, 
    o.total_amount, 
    AVG(o.total_amount) OVER(PARTITION BY p.category) AS avg_order_by_category
FROM orders o
JOIN product_items p 
	ON o.product_id = p.product_id; 


# counting orders per customer 

SELECT 
	order_id, 
    customer_id, 
    COUNT(order_id) OVER(PARTITION BY customer_id) AS total_orders
FROM orders;

# lag, lead

# previous and next order amount 

SELECT 
	order_id, 
    customer_id, 
    total_amount, 
    LAG(total_amount) OVER(PARTITION BY customer_id ORDER BY order_date) AS previous_order, 
    LEAD(total_amount) OVER(PARTITION BY customer_id ORDER BY order_date) AS next_order
FROM orders;



# analyzing customer purhcases in the order table: 

SELECT 
	order_id, 
    customer_id,
    total_amount,
    order_date, 
    
    -- Ranking 
    ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS row_num, 
    RANK() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS rank_num,
    DENSE_RANK() OVER(PARTITION BY customer_id ORDER BY total_amount DESC) AS dense_rank_num,
    
    -- Analyzing the amount by using aggregation with partitioning 
    SUM(total_amount) OVER(PARTITION BY customer_id) AS total_spent, 
    AVG(total_amount) OVER(PARTITION BY customer_id) AS avg_spent, 
    COUNT(order_id) OVER(PARTITION BY customer_id) AS total_orders,
    
    -- Running total (cumulative sum) 
    SUM(total_amount) OVER(PARTITION BY customer_id ORDER BY order_date) AS running_total, 
    
    -- Next order 
    LEAD(total_amount) OVER(PARTITION BY customer_id ORDER BY order_date) AS next_order
FROM orders;



# Temp Tables 

CREATE TEMPORARY TABLE temp_sales_data AS
SELECT product_id, SUM(total_amount) AS total_sales 
FROM orders 
GROUP BY product_id;

SELECT product_id, total_sales
FROM temp_sales_data
WHERE total_sales > 500;

SELECT *
FROM temp_sales_data;

DROP TEMPORARY TABLE temp_sales_data;


# Tigger 

CREATE DATABASE trig_example; 

USE trig_example; 

CREATE TABLE employees
(
	id INT PRIMARY KEY, 
    emp_name VARCHAR(50), 
    emp_position VARCHAR(50)
); 

INSERT INTO employees 
VALUES 
(1, "Aung Aung", "Manager"),
(2, "Ko Aye", "Developer"),
(3, "Sandar", "Analyst"), 
(4, "Amy", "Designer");

SELECT * FROM employees;

# creating the employee_log table for backup 

CREATE TABLE employees_log
(
	id INT PRIMARY KEY, 
    emp_name VARCHAR(50), 
    emp_position VARCHAR(50), 
    deleted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
); 


# creating the trigger for deletions 

DELIMITER $$ 

CREATE TRIGGER before_employee_delete 
BEFORE DELETE ON employees 
FOR EACH ROW 
BEGIN 
	INSERT INTO employees_log (id, emp_name, emp_position)
    VALUES(OLD.id, OLD.emp_name, OLD.emp_position);
END $$

DELIMITER ;

SELECT * FROM employees;

DELETE FROM employees
WHERE id = 2;

SELECT * FROM employees_log;

# Syntax 

# step 1: dont forget to create a backup table 

# step 2: create trigger 

#CREATE TRIGGER trigger_name 
#{BEFORE | AFTER} {INSERT | UPDATE | DELETE} ON employees 
#FOR EACH ROW 
#BEGIN 
#	-- INSERT INTO syntax;
#END $$


# CTE (Common Table Expression)

WITH cte_example01 AS
(
SELECT 
	gender, 
    AVG(total_amount) AS avg_amount, 
    MAX(total_amount) AS max_amount, 
    MIN(total_amount) AS min_amount, 
    COUNT(total_amount) AS count_amt
FROM orders o 
JOIN customers c
	ON o.customer_id = c.customer_id
GROUP BY gender
)
SELECT AVG(avg_amount) 
FROM cte_example01;

SELECT AVG(total_amount) 
FROM orders;

# SUBQUERY 

SELECT AVG(avg_amount) 
FROM (
	SELECT 
		gender, 
		AVG(total_amount) AS avg_amount, 
		MAX(total_amount) AS max_amount, 
		MIN(total_amount) AS min_amount, 
		COUNT(total_amount) AS count_amt
	FROM orders o 
	JOIN customers c
		ON o.customer_id = c.customer_id
	GROUP BY gender) eg_subq;


# WITH table_cte AS 
#	(SELECT ----
#    FROM --) table1_cte, 
#    (SELECT ----
#    FROM --) table2_cte,
# FROM table1_cte 
# JOIN table2_cte 
# ON..;


# date of birth 1990-01-01, total_amount > 500

WITH cte_eg1 AS 
(
	SELECT customer_id, gender, date_of_birth
    FROM customers
    WHERE date_of_birth > "1990-01-01"
), 
cte_eg2 AS 
( 
	SELECT customer_id, total_amount 
    FROM orders 
    WHERE total_amount > 500
)
SELECT *
FROM cte_eg1 
JOIN cte_eg2 
	ON cte_eg1.customer_id = cte_eg2.customer_id;

# JOIN 

SELECT 
	c.customer_id, 
    c.gender,
    c.date_of_birth, 
    o.total_amount
FROM customers c
JOIN orders o 
	ON c.customer_id = o.customer_id
WHERE c.date_of_birth > "1990-01-01" AND o.total_amount > 500;


# SUBQUERY 

SELECT 
	c.customer_id, 
    c.gender,
    c.date_of_birth, 
    o.total_amount
FROM 
	(SELECT customer_id, gender, date_of_birth
    FROM customers
    WHERE date_of_birth > "1990-01-01") AS c 
JOIN 
	(SELECT customer_id, total_amount 
    FROM orders 
    WHERE total_amount > 500) AS o
ON c.customer_id = o.customer_id;


# total spent per customer by ranking 

WITH customersales AS 
(
SELECT 
	o.customer_id, 
    SUM(o.total_amount) AS total_spent
FROM orders o 
GROUP BY o.customer_id),
ranksales AS 
(
SELECT 
	cs.customer_id, 
    cs.total_spent,
    ROW_NUMBER() OVER(ORDER BY cs.total_spent DESC) AS rank1
FROM customersales cs
)
SELECT 
	r.rank1, 
    c.first_name, 
    c.last_name,
    r.total_spent
FROM ranksales r 
JOIN customers c
	ON r.customer_id = c.customer_id
ORDER BY r.rank1
LIMIT 3;

# SELECT, WHERE, GROUP BY, HAVING, ORDER BY, LIMIT, AS

# JOIN, GROUP BY, SUBQUERY, CTE, TEMP TABLEs, WINDOW, 
# CASE 
# UNION

# CREATE DB, Table, View, procedure  

# Insert, Update, Delete 

# SELECT * FROM 

# Trigger, Stored Procedure

-- VIEW, TEMP TABLE, CTE

# Stored Procedure 

CREATE PROCEDURE older_customers()
SELECT * 
FROM customers
WHERE age > 40;

CALL older_customers();

DELIMITER $$
CREATE PROCEDURE older_customer2()
BEGIN 
	SELECT * 
    FROM customers
    WHERE age > 30; 
    
    SELECT * 
    FROM customers 
    WHERE age > 40;
END $$
DELIMITER ;

CALL older_customer2();

DROP PROCEDURE new_procedure;


# with parameter ** 

DELIMITER $$ 
CREATE PROCEDURE customertotalsales
(
	IN customerId INT,
    IN startDate DATE, 
    IN endDate DATE
)
BEGIN 
	SELECT 
		SUM(total_amount) AS total_sales 
        FROM orders 
        WHERE customer_id = customerId
			AND order_date BETWEEN startDate AND endDate;
END $$
DELIMITER ;

CALL customertotalsales(10, "2025-01-01", "2025-12-31");


# Insert Statement 

INSERT INTO orders 
VALUES (XXXX);

# copy customer data from customer table to new customer_backup table 

# 1. create backup table manually 
CREATE TABLE customers_backup
(
	customer_id INT AUTO_INCREMENT PRIMARY KEY, 
    first_name VARCHAR(50), 
    last_name VARCHAR(50), 
    date_of_birth DATE, 
    age INT, 
    gender VARCHAR(10), 
    email VARCHAR(100), 
    address VARCHAR(255), 
    city VARCHAR(50), 
    state VARCHAR(50),
    country VARCHAR(50)
);

# alternative ways to create tables with the same structure 

# if you wanna create a table with the same structure without copying index or contraints 

CREATE TABLE table_backup AS 
SELECT * FROM org_table WHERE 1=0;

CREATE TABLE customers_backup2 AS 
SELECT * FROM customers WHERE 1=0;

# including index & constraints 
# only available in MySQL 

CREATE TABLE customer_backup3 LIKE customers;

SELECT * FROM customers_backup2;

-- copy selected data from customer table to customer_backup 

INSERT INTO customers_backup2 (first_name, last_name, date_of_birth, age, gender, email, address, city)
SELECT first_name, last_name, date_of_birth, age, gender, email, address, city
FROM customers 
WHERE city = "Chicago";

-- copy all columns from ONE to ANOTHER table 

INSERT INTO customer_backup3
SELECT * FROM customers;

SELECT * FROM customer_backup3;
SELECT * FROM customers;